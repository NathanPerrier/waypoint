<template>
    <div class="page" data-name="routeDesktopPage">
        <div class="page-content">

            <a href="#view-home" id="go-back"  class="tab-link tab-link-active">        
                <i class="fa fa-arrow-left fa-2x"></i>        
            </a>
            <div id="map" class="h-100 w-100"></div>
        </div>
    </div>

</template>
<script>    
export default async (props, { $, $on, $f7 }) => {

    $on('pageInit', async () => {
        const app = window.app;

        mapboxgl.accessToken = app.MAPBOX_ACCESS_TOKEN;

        const map = new mapboxgl.Map({
            container: 'map', //! TODO: change to du=ocument and rename id
            zoom: 11.53,
            center: [6.5615, 46.0598],
            pitch: 65,
            bearing: -180,
            // Choose from Mapbox's core styles, or make your own style with Mapbox Studio
            style: app.MAP_3D_STYLE, // style URL
            interactive: false
        });

        // `routes` comes from https://docs.mapbox.com/mapbox-gl-js/assets/routes.js,
        // which has properties that are in the shape of an array of arrays that correspond
        //  to the `coordinates` property of a GeoJSON linestring, for example:

        // const routes = {
        //    target: [
        //        [6.56158447265625, 46.059891147620725],
        //        [6.5691375732421875, 46.05679376154153],
        //    ]
        // };

        // this is the path the camera will look at
        const targetRoute = routes.target;
        // this is the path the camera will move along
        const cameraRoute = routes.target;
    
        // add terrain, sky, and line layers once the style has loaded
        map.on('style.load', () => {
            map.addSource('mapbox-dem', {
                'type': 'raster-dem',
                'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
                'tileSize': 512,
                'maxzoom': 14
            });
            map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1 });  // exaggeration: 1.5
            map.addSource('trace', {
                type: 'geojson',
                data: {
                    'type': 'Feature',
                    'properties': {},
                    'geometry': {
                        'type': 'LineString',
                        'coordinates': targetRoute // smooth the target route
                    }
                }
            });
            map.addLayer({
                type: 'line',
                source: 'trace',
                id: 'line',
                paint: {
                    'line-color': app.PRIMARY_COLOR,
                    'line-width': 16
                },
                layout: {
                    'line-cap': 'round',
                    'line-join': 'round'
                }
            });
        });
    
        // wait for the terrain and sky to load before starting animation
        map.on('load', () => {
            const animationDuration = 1000000;

            const relativeCameraAltitude = 200; 
            
            const routeDistance = turf.lineDistance(turf.lineString(targetRoute));
            const cameraRouteDistance = turf.lineDistance(
                turf.lineString(cameraRoute)
            );

            // Pre-calculate cumulative distances for segment identification
            const cumulativeDistances = [0];
            for (let i = 0; i < cameraRoute.length - 1; i++) {
                const dist = turf.distance(turf.point(cameraRoute[i]), turf.point(cameraRoute[i+1]));
                cumulativeDistances.push(cumulativeDistances[i] + dist);
            }

            // Define how far ahead the camera should look
            const lookAheadFactor = 0.005; // Adjust this value to control how far ahead the camera looks (as a fraction of total route distance)
            const lookAheadDistance = routeDistance * lookAheadFactor;

            let start;

            // Updated the camera animation logic to ensure smooth transitions between nodes.
            function frame(time) {
                if (!start) start = time;
                const phase = (time - start) / animationDuration;

                if (phase >= 1) {
                    // Reset animation or stop
                    setTimeout(() => {
                        start = 0.0; // Loop the animation
                    }, 1500);
                    window.requestAnimationFrame(frame);
                    return;
                }

                // Calculate current position along the camera path
                const currentDistance = cameraRouteDistance * phase;
                const cameraPosition = turf.along(
                    turf.lineString(cameraRoute),
                    currentDistance
                );
                const cameraPositionCoords = cameraPosition.geometry.coordinates;

                // Calculate the look-at position slightly ahead on the target path
                const lookAtTargetDistance = Math.min(routeDistance, currentDistance + lookAheadDistance); // Ensure look-at doesn't go beyond the route end
                const lookAtPosition = turf.along(
                    turf.lineString(targetRoute),
                    lookAtTargetDistance
                );
                const lookAtCoords = lookAtPosition.geometry.coordinates;

                // Calculate terrain elevation at the camera's current position
                const terrainElevation = map.queryTerrainElevation(cameraPositionCoords) || 0;
                const finalAltitude = terrainElevation + relativeCameraAltitude;

                // Set camera options
                const camera = map.getFreeCameraOptions();
                camera.position = mapboxgl.MercatorCoordinate.fromLngLat(
                    {
                        lng: cameraPositionCoords[0],
                        lat: cameraPositionCoords[1]
                    },
                    finalAltitude
                );
                camera.lookAtPoint({
                    lng: lookAtCoords[0],
                    lat: lookAtCoords[1],
                });

                map.setFreeCameraOptions(camera); // Removed curve:'linear' as it's not a valid option here

                window.requestAnimationFrame(frame);
            }

            window.requestAnimationFrame(frame);
        });
    });
    return $render;
}
</script>
